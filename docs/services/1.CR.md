---
descript: 由 copilot(Gemini 3 Pro) 生成，看看行不行
versions:
  - '0.1':
    prompt:
      - |
        `根据现在 #file:request 的代码，补充完成 #file:1.CR.md 文件撰写`
    comment: 不是很理想？重点放错了，初级内容重点分析，构建架构没有体现
  - '0.2':
    prompt:
      - |
        在 `docs\services\1.CR.md` 的 `# 现状` 段落中以对services实现进行一次现状总结。期望输出内容包含：
        1. 一个总体架构的总结、描述
        2. 以`getBookListByIds`调用为起点，以`getBookListByIds`得到响应为终点，以文件为粒度，一个文件一个子段落，总结途中用到的文件及其内容总结
        3. end
      - |
        根据`docs\services\1.CR.md`的`# 现状`段落进行优劣总结
    comment: |
      很难评价这个评判输出？不能说它错了or它没输出有用的东西。
      但有种“很难用它来代替看代码”的感觉。为什么会这样...
      某种角度是否提示了我开源的本质：让价值从代码（写出来什么）变成人(为什么这么写)
---

# 现状

## 总体架构

项目采用了 **双通道通信策略**，核心业务主要依赖 **SignalR (WebSocket)** 进行实时、高效的数据交互，同时保留 **Fetch (HTTP)** 作为备用或特定场景的请求方式。

- **通信协议**: SignalR 通道采用了 **MessagePack** 二进制协议，并结合 **Gzip** 压缩，显著降低了网络负载。
- **流控机制**: 实现了 `RateLimitQueue` 对请求进行速率限制，防止突发流量冲击服务端。
- **离线/弱网支持**: 实现了 **Cache-First** 策略，在断网或连接未建立时优先读取本地缓存（IndexedDB），提升用户体验。
- **鉴权机制**: 采用 Session Token + LongTerm Token 的双 Token 机制，在 SignalR 连接建立时自动处理 Token 刷新。
- **可观测性**: 内置 `SignalRInspector`，在开发环境下提供详细的请求链路追踪和日志记录。

## 调用链路分析：以 `getBookListByIds` 为例

以下以 `getBookListByIds` 接口调用为例，梳理从业务层发起请求到最终获取响应的完整链路及涉及的关键文件。

### 1. 业务入口: `src/services/book/index.ts`

这是书籍相关服务的入口文件。

- **功能**: 定义了 `getBookListByIds` 函数。
- **逻辑**:
  - 首先进行参数校验（如限制批量查询 ID 数量不超过 24 个）。
  - 调用 `requestWithSignalr` 发起请求，指定方法名 `'GetBookListByIds'` 和参数 `{ Ids: ids }`。
  - 明确了泛型返回值类型 `<Types.BookInList[]>`。

### 2. 统一出口: `src/services/internal/request/index.ts`

这是请求层的统一导出文件。

- **功能**: 重新导出 `requestWithSignalr`。
- **逻辑**: 将 `src/services/internal/request/signalr/index.ts` 中的实现暴露给外部使用。

### 3. 核心实现: `src/services/internal/request/signalr/index.ts`

这是 SignalR 请求的核心实现文件，包含最复杂的逻辑。

- **功能**: 导出了经过流控包装的 `requestWithSignalr` (即 `requestWithSignalrInRateLimit`)。
- **逻辑**:
  - **流控**: 使用 `queue.add(() => ...)` 将请求加入队列，确保请求频率符合限制。
  - **连接管理**: 维护 `HubConnection` 实例。通过 `buildHub` 创建连接，配置了 `MessagePackHubProtocol`、`RetryPolicy` 以及 `accessTokenFactory`（用于 Token 自动刷新）。
  - **请求流程**:
    1. **Inspector**: 初始化 `SignalRInspector` 用于链路追踪。
    2. **连接检查**: 尝试确保连接已建立 (`firstConnect`)。
    3. **缓存降级**: 如果当前未连接 (`HubConnectionState.Connected`)，尝试调用 `tryResponseFromCache` 读取本地缓存。
    4. **发送请求**: 调用 `hub.invoke(url, ...data)` 发送数据。
    5. **响应处理**:
       - 接收响应，如果是 `Uint8Array` 则进行 Gzip 解压 (`pako.ungzip`) 并 JSON 解析。
       - 检查响应体中的 `Success` 字段。
       - **成功**: 调用 `updateResponseCache` 更新缓存，返回 `Response` 数据。
       - **失败**: 抛出 `ServerError`，如果是鉴权失败则触发 `unAuthenticationNotify`。

### 4. 流控队列: `src/services/internal/request/createRequestQueue.ts`

- **功能**: 创建并导出全局唯一的请求队列 `queue`。
- **逻辑**: 实例化 `RateLimitQueue`，配置速率限制（例如每 5.5 秒 10 个请求），平滑请求流量。

### 5. 缓存管理: `src/services/internal/request/signalr/cache.ts`

- **功能**: 管理 SignalR 请求的本地缓存。
- **逻辑**:
  - `tryResponseFromCache`: 根据 URL 和参数生成 Key，从 `signalrCacheDB` (IndexedDB) 中读取缓存。
  - `updateResponseCache`: 请求成功后，将最新的响应数据写入 `signalrCacheDB`。

### 6. 链路追踪: `src/services/internal/request/signalr/inspector.ts`

- **功能**: 记录请求生命周期中的关键事件。
- **逻辑**: 记录 INIT, SENT, REVICE, SUCCESS, FAIL 等状态和时间戳。在开发模式下 (`process.env.VUE_TRACE_SERVER`) 将日志输出到控制台，便于调试。

### 7. 错误定义: `src/services/internal/ServerError.ts`

- **功能**: 定义统一的服务端错误类。
- **逻辑**: 继承自 `Error`，包含 `message` 和 `status` 属性，用于在业务层捕获并处理 API 错误。

# 优

1.  **通信效率高**:
    - 采用 SignalR 长连接配合 MessagePack 二进制协议及 Gzip 压缩，大幅减少了 HTTP 握手开销和数据传输量。
2.  **用户体验好**:
    - 实现了 Cache-First 策略，在弱网环境下能快速展示内容。
    - 自动重连和 Token 刷新机制对用户透明，保证了会话的连续性。
3.  **系统稳定性**:
    - 通过 `RateLimitQueue` 实现了客户端侧的流量控制，有效防止了高频请求对服务端的冲击。
4.  **开发体验佳**:
    - 提供了 `SignalRInspector` 可视化工具，方便调试复杂的异步请求链路。
    - 全链路 TypeScript 类型支持，保证了代码的健壮性。

# 劣

1.  **职责耦合严重**:
    - `requestWithSignalr` 函数承担了过多的职责（连接管理、缓存读写、Gzip 解压、错误处理、日志记录），违反了单一职责原则，导致代码难以维护和测试。
2.  **逻辑复用困难**:
    - 缓存逻辑、重试逻辑与 SignalR 请求强绑定，难以复用到 Fetch 请求或其他业务场景中。
3.  **配置硬编码**:
    - 速率限制参数（如 5.5s/10次）、批量查询限制（24本）等关键配置散落在代码各处，缺乏统一配置管理。
4.  **错误处理隐晦**:
    - 缓存降级逻辑可能掩盖真实的网络或服务错误，导致问题排查困难。
    - 部分错误处理逻辑（如鉴权失败通知）侵入在底层请求库中，导致分层不清晰。
5.  **双通道维护成本**:
    - 同时维护 SignalR 和 Fetch 两套机制，且两者在拦截器、缓存策略等方面实现不一致，增加了维护负担。
