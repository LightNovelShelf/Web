---
descript: 由 copilot(Gemini 3 Pro) 生成，看看行不行
versions:
  - '0.1':
    prompt:
      - |
        `根据现在 #file:request 的代码，补充完成 #file:1.CR.md 文件撰写`
    comment: 不是很理想？重点放错了，初级内容重点分析，构建架构没有体现
  - '0.2':
    prompt:
      - |
        在 `docs\services\1.CR.md` 的 `# 现状` 段落中以对services实现进行一次现状总结。期望输出内容包含：
        1. 一个总体架构的总结、描述
        2. 以`getBookListByIds`调用为起点，以`getBookListByIds`得到响应为终点，以文件为粒度，一个文件一个子段落，总结途中用到的文件及其内容总结
        3. end
      - |
        根据`docs\services\1.CR.md`的`# 现状`段落进行优劣总结
    comment: |
      很难评价这个评判输出？不能说它错了or它没输出有用的东西。
      但有种“很难用它来代替看代码”的感觉。为什么会这样...
      某种角度是否提示了我开源的本质：让价值从代码（写出来什么）变成人(为什么这么写)
  - '0.3':
    comment: |
      回归手写，AI撰写内容的架构倒是挺值得参考的
      希望看AI输出可以去git-log里翻
---

# 现状

## 总体架构

```text
# 注：这个结构并不等同文件结构; 斜杠结尾 代表 文件夹
src/                              \\\\\\\\ root
|- request/                       ////////
│  ├─ signalr/                    \\\\\\\\
│  │  ├─ index                    ////////
│  │  │  ├─ requestWithSignalr    \\\\\\\\ signalr 请求的主要实现
│  │  │  ├─ subscribeWithSignalr  //////// signalr 提供的推送服务
│  │  ├─ cache                    \\\\\\\\ indexed-db 、 以 json(url+body) 为key 的 cache 服务; 期望对齐的是Cache API能力
│  │  ├─ inspector                //////// signalr 的 请求情况 支持（因为 dev-tool#network 对 signalr 的请求情况展示不是很友好）
│  │  ├─ RetryPolicy              \\\\\\\\ 给 signalr 写的retry策略配置，应该可以优化掉
│  ├─ fetch                       ////////
│  │  ├─ requestWithFetch         \\\\\\\\ fetch 请求的主要实现
│  ├─ createRequestQueue          //////// 请求前置队列
│  │  ├─ RateLimitQueue           \\\\\\\\ 实现 “n秒内最多m次消费” 队列
│  ├─ ServerError                 //////// 所有请求公用的服务错误对象
|- utils/                         \\\\\\\\
│  |- useServerNotify             //////// subscribeWithSignalr 的 胶水封装
│  |- useCacheNotify              \\\\\\\\ 目前似乎没有地方在用，代码也明显写错了(`watch(ref.value || {}, cb)`)，我当时在想什么？
```

### signalr

TODO:

# 优

1.  **通信效率高**:
    - 采用 SignalR 长连接配合 MessagePack 二进制协议及 Gzip 压缩，大幅减少了 HTTP 握手开销和数据传输量。
2.  **用户体验好**:
    - 实现了 Cache-First 策略，在弱网环境下能快速展示内容。
    - 自动重连和 Token 刷新机制对用户透明，保证了会话的连续性。
3.  **系统稳定性**:
    - 通过 `RateLimitQueue` 实现了客户端侧的流量控制，有效防止了高频请求对服务端的冲击。
4.  **开发体验佳**:
    - 提供了 `SignalRInspector` 可视化工具，方便调试复杂的异步请求链路。
    - 全链路 TypeScript 类型支持，保证了代码的健壮性。

# 劣

1.  **职责耦合严重**:
    - `requestWithSignalr` 函数承担了过多的职责（连接管理、缓存读写、Gzip 解压、错误处理、日志记录），违反了单一职责原则，导致代码难以维护和测试。
2.  **逻辑复用困难**:
    - 缓存逻辑、重试逻辑与 SignalR 请求强绑定，难以复用到 Fetch 请求或其他业务场景中。
3.  **配置硬编码**:
    - 速率限制参数（如 5.5s/10次）、批量查询限制（24本）等关键配置散落在代码各处，缺乏统一配置管理。
4.  **错误处理隐晦**:
    - 缓存降级逻辑可能掩盖真实的网络或服务错误，导致问题排查困难。
    - 部分错误处理逻辑（如鉴权失败通知）侵入在底层请求库中，导致分层不清晰。
5.  **双通道维护成本**:
    - 同时维护 SignalR 和 Fetch 两套机制，且两者在拦截器、缓存策略等方面实现不一致，增加了维护负担。
