---
versions:
  - '0.1':
      descript: |
        由 copilot(Gemini 3 Pro) 生成，看看行不行
        `根据现在 #file:request 的代码，补充完成 #file:1.CR.md 文件撰写`
        不是很理想？重点放错了，初级内容重点分析，构建架构没有体现
---

# 现状

目前项目采用了 **双通道通信策略**，主要依赖 **SignalR (WebSocket)** 进行实时和高效的数据交互，同时保留 **Fetch (HTTP)** 作为基础的请求方式。

## 核心架构

1.  **SignalR (主通道)**:
    - **协议**: 使用 `MessagePackHubProtocol` 进行二进制序列化，支持 Gzip 压缩（通过检测 `Uint8Array` 响应），减少传输体积。
    - **连接管理**: 实现了自动重连机制 (`RetryPolicy`)，重试间隔为 0s -> 5s -> 10s -> 20s -> 30s。
    - **鉴权**: 在连接建立时通过 `accessTokenFactory` 处理 Token，支持使用 LongTermToken 自动刷新 SessionToken。
    - **缓存策略**: 内置了基于 IndexedDB 的缓存机制 (`signalrCacheDB`)。在连接未建立时，优先尝试返回缓存数据，实现“离线可用”或“弱网优化”。
    - **调试**: 包含 `SignalRInspector`，在开发环境下可追踪请求的全生命周期（发送、接收、缓存命中、失败等）。

2.  **Fetch (备用/基础通道)**:
    - **流控**: 集成了 `RateLimitQueue`，限制请求速率（约 5秒 10次），防止客户端并发过高。
    - **指纹**: 请求头包含 `x-id` (VisitorId)，用于设备标识。
    - **标准化**: 统一了 GET (QueryString) 和 POST (JSON/FormData) 的处理逻辑，并对响应进行了统一的错误封装 (`ServerError`)。

# 优

1.  **高性能与体验**:
    - SignalR 结合 MessagePack 和 Gzip 显著降低了网络负载。
    - 缓存优先策略让应用在弱网或断网环境下仍能展示部分内容，提升用户体验。
2.  **健壮性**:
    - SignalR 的自动重连和 Token 刷新机制保证了长连接的稳定性。
    - Fetch 的速率限制保护了服务端免受突发流量冲击。
3.  **可观测性**:
    - `SignalRInspector` 提供了详细的请求链路日志，极大方便了异步通信的调试。
4.  **类型安全**:
    - 代码中广泛使用了 TypeScript 泛型，保证了请求和响应数据的类型安全。

# 劣

1.  **一致性缺失**:
    - **流控不统一**: Fetch 请求受 `RateLimitQueue` 限制，但 SignalR 请求似乎未接入该队列，可能导致 WebSocket 通道在高并发下压力过大。
    - **缓存不统一**: 仅 SignalR 通道实现了缓存机制，Fetch 请求缺乏统一的缓存处理，导致两种请求方式的行为不一致。
2.  **逻辑复杂性**:
    - 维护两套请求逻辑（SignalR 和 Fetch）增加了维护成本。
    - SignalR 的 `requestWithSignalr` 函数中混合了 缓存读取、连接状态检查、请求发送、Gzip 解压、错误处理 等多重逻辑，函数职责略显臃肿。
3.  **错误处理隐患**:
    - 在 `requestWithSignalr` 中，为了降级使用缓存，部分错误（如缓存读取失败）被静默吞没，可能掩盖潜在问题。
    - `@todo` 注释表明“请求失败后是否使用缓存代替”的策略尚未完全确定，存在逻辑上的不确定性。
4.  **硬编码**:
    - 重试策略的时间间隔和限流队列的参数直接硬编码在文件中，缺乏配置灵活性。
