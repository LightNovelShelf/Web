---
descript: 由 copilot(Gemini 3 Pro) 生成，看看行不行
versions:
  - '0.1':
    prompt:
      - |
        `根据现在 #file:request 的代码，补充完成 #file:1.CR.md 文件撰写`
    comment: 不是很理想？重点放错了，初级内容重点分析，构建架构没有体现
  - '0.2':
    prompt:
      - |
        在 `docs\services\1.CR.md` 的 `# 现状` 段落中以对services实现进行一次现状总结。期望输出内容包含：
        1. 一个总体架构的总结、描述
        2. 以`getBookListByIds`调用为起点，以`getBookListByIds`得到响应为终点，以文件为粒度，一个文件一个子段落，总结途中用到的文件及其内容总结
        3. end
      - |
        根据`docs\services\1.CR.md`的`# 现状`段落进行优劣总结
    comment: |
      很难评价这个评判输出？不能说它错了or它没输出有用的东西。
      但有种“很难用它来代替看代码”的感觉。为什么会这样...
      某种角度是否提示了我开源的本质：让价值从代码（写出来什么）变成人(为什么这么写)
  - '0.3':
    comment: |
      回归手写，AI撰写内容的架构倒是挺值得参考的
      希望看AI输出可以去git-log里翻
---

# 现状

## 总体架构

```text
# 注：这个结构并不等同文件结构; 斜杠结尾 代表 文件夹
src/                              \\\\\\\\ root
|- request/                       ////////
│  ├─ signalr/                    \\\\\\\\
│  │  ├─ index                    ////////
│  │  │  ├─ requestWithSignalr    \\\\\\\\ signalr 请求的主要实现
│  │  │  ├─ subscribeWithSignalr  //////// signalr 提供的推送服务
│  │  ├─ cache                    \\\\\\\\ indexed-db 、 以 json(url+body) 为key 的 cache 服务; 期望对齐的是Cache API能力
│  │  ├─ inspector                //////// signalr 的 请求情况 支持（因为 dev-tool#network 对 signalr 的请求情况展示不是很友好）
│  │  ├─ RetryPolicy              \\\\\\\\ 给 signalr 写的retry策略配置，应该可以优化掉
│  ├─ fetch                       ////////
│  │  ├─ requestWithFetch         \\\\\\\\ fetch 请求的主要实现
│  ├─ createRequestQueue          //////// 请求前置队列
│  │  ├─ RateLimitQueue           \\\\\\\\ 实现 “n秒内最多m次消费” 队列
│  ├─ ServerError                 //////// 所有请求公用的服务错误对象
|- utils/                         \\\\\\\\
│  |- useServerNotify             //////// subscribeWithSignalr 的 胶水封装
│  |- useCacheNotify              \\\\\\\\ 目前似乎没有地方在用，代码也明显写错了(`watch(ref.value || {}, cb)`)，我当时在想什么？
```

## 优

- 适当封装了 signalr 的细节，让 signalr 用起来跟 fetch 差别不大
  - 包括 inspector ，真帅
- 包含基础错误处理封装
- 实现了请求控制，包括频率限制/cache
- 有意识封装 vue 业务 与 services 业务的胶水层

## 劣

排名分先后

1. 对 signalr 的封装没有识别出 有/无状态 这个核心区别，导致 subscribe 类业务封装比较突兀
   1. signalr 状态维护混在整个抽象中， 其中的抽象 跟 代码片段 一样，沒有体现逻辑性
   1. firstConnect/getSignalr 定位有点混乱，让整个 requestWithSignalr 的连接状态管理比较难以阅读
   1. getSignalr 内部的重试跟 signalr 的重试在定位上有点混乱不清
1. 抽象耦合严重，相互交叉，有些共用有些不共用，基本没办法只看自己就知道自己会被怎么使用
1. 应用切后台一段时间后回来会有没有connect的错误提示
1. 太多的抽象不会组织，造成大量的冗余class，其实根本不需要new

# 改进

1. 对 signalr 整体做一个抽象，对外不暴露构造器参数等细节，只保留能力与状态
   1. 保留 cache/inspector 设定
   1. 对外提供 invoke / subscribe(on+off) / reboot 的能力组合
      1. 其实也可以暴露底层的hub，这个到时候权衡一下成本收益
2. 封装出一个类 axios 的请求界面，支持拦截器与参数
   1. 类状态机的抽象思路或许值得考虑：中间件可以重启请求
3. 在`2.`的外层wrap流控逻辑，不分开初始化
   1. 考虑到原 [issue](https://github.com/LightNovelShelf/Web/issues/7) 的沟通记录，流控最大的意图属于控制并发
