# 业务场景

- 登陆 使用 不带token的 `widow.fetch` 请求
- 重置密码 使用 带token的 `widow.fetch` 请求
- 订阅通知 使用 `signalr.on(evt)` 接收通知
- 大部分业务请求 使用 `signalr.invoke(method, args)` 发出并等待响应，实现类似 req-res 形式的通信
- 连接状态组件 期望 能感知 `signalr` 的连接状态，方便直观给用户展示通信状态
- 服务器选择会切换 请求 的目标域名，包括 `window.fetch` 和 `signalr` 的连接
- 登录/退出登录 需要通知 `signalr` 切换身份，目前方法是 处理token记录后重启 `signalr` 连接

# Think

- 所以还是分两类，`fetch(xhr)`/`signalr`
  - 分成两类最开始是野兽本能，觉得在一个实现里融合两个类型的请求有点困难，“有点不一样”
  - 经过一些分析与纠结，发现这两最大的区别在于：**一个无状态，一个有状态**
  - 上传进度的回调目前还是`xhr`专属的功能，有保留兼容的价值
- 目标还是不变：期望业务不需要知道实现细节，只需要知道 **给什么，拿到什么** ，不传通信层相关的选项
  - 但通信类型还是需要感知的，有状态和无状态的形式不一样，能提供的东西也不一样
- 根据场景分析，带状态的`signalr`需要对外暴露关于连接状态&行为的抽象
  - 正常的 类无状态请求能力
  - 登陆/退出登陆/切换请求目标 需要打断重连
  - 应用层 需要有订阅消息的能力
  - 个人中心 需要能感知连接状态、行为
    - 从需求上来看，这个类似于“订阅”
    - 考虑到我们在一个vue上下文中，可以利用reactive来实现类似机制
- 该在哪一层做两个方案在 无状态请求 场景的抹平？
  - 1. 调用services时：挑哪一个实现去send
  - 2. 实现services时：抹平差异，但其实还是得标记？
  - 就像2里提到的，无论如何标记用什么实现是必不可少得，以及保不准支持的内容、序列化策略也不一样，还是在调的时候做区别比较好
- 简单的CR？不然做一个只是形状不一样的抽象出来没有意思
  - [1.CR](./1.CR.md)
- [2.实现手记](./2.实现手记.md)
- 抽象的过程也是持续的，无论时TDD还是DDD都强调了持续改进的存在
  - 不必追求先做好百分百的文档再做实现

-eof-
