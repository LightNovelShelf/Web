# 手记

1. 对 signalr 整体做一个抽象，对外不暴露构造器参数等细节，只保留能力与状态
   1. 保留 cache/inspector 设定
   1. 对外提供 invoke / subscribe(on+off) / reboot 的能力组合
      1. 其实也可以暴露底层的hub，这个到时候权衡一下成本收益
1. 封装出一个类 axios 的请求界面，支持拦截器与参数
   1. 类状态机的抽象思路或许值得考虑：中间件可以重启请求
   1. 在其之上做wrap流控逻辑，不分开初始化
1. signal与http可以在“无状态”这个层级的抽象上融合，但不能再往下继续抽象融合：协议的底层实在区别太大，如 payload编码/http特性区别

## 并发限制

参考原[issue](https://github.com/LightNovelShelf/Web/issues/7)的沟通记录，项目中`RateLimitQueue`的实现目的仅是并发控制。
对比起这个目的，队列这个概念更倾向于对消费行为的控制，业务把控制权委托给队列控制器，借此实现消费行为的“塑形”，如满足什么特征/频率，甚至控制流（if/else/then/throw）的更改。
如果仅是针对并发控制，采用最简单的counter即可满足（无需考虑时间窗口），这在代码体积/性能上都有更好表现；无需追求大而全的队列维护与行为塑形。

## time-line

### 2025-12-28

- ~~明确了`await start`应该被`invoke`自身包裹的方向~~
  - ~~但写出来感觉不太对，大概是没往正确的方向思考的感觉~~
  - 库提供操作原语，我利用状态管理封装原语为能力；类似js-dom与vue的关系
